{"version":3,"file":"mobile.special.watchlist.scripts.js","mappings":"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","sources":["webpack://mfModules/./src/mobile.special.watchlist.scripts/PageList.js","webpack://mfModules/./src/mobile.special.watchlist.scripts/ScrollEndEventEmitter.js","webpack://mfModules/./src/mobile.special.watchlist.scripts/WatchList.js","webpack://mfModules/./src/mobile.special.watchlist.scripts/WatchListGateway.js","webpack://mfModules/./src/mobile.special.watchlist.scripts/WatchstarGateway.js","webpack://mfModules/./src/mobile.special.watchlist.scripts/WatchstarPageList.js","webpack://mfModules/./src/mobile.special.watchlist.scripts/extendSearchParams.js","webpack://mfModules/./src/mobile.special.watchlist.scripts/mobile.special.watchlist.scripts.js","webpack://mfModules/./src/mobile.special.watchlist.scripts/pageJSONParser.js","webpack://mfModules/./src/mobile.special.watchlist.scripts/watchstar.js"],"sourcesContent":["const util = require( '../mobile.startup/util.js' ),\n\tView = require( '../mobile.startup/View' ),\n\tbrowser = require( '../mobile.startup/Browser' ).getSingleton();\n\n/**\n * List of items page view\n */\nclass PageList extends View {\n\tconstructor( params ) {\n\t\tsuper( params );\n\t}\n\n\t/**\n\t * @mixes module:mobile.startup/View#defaults\n\t * @property {Object} defaults Default options hash.\n\t * @property {Page[]} defaults.pages Array of Page objects. These should match\n\t *                              the Page model and not necessarily the\n\t *                              underlying API format used.\n\t * E.g. [\n\t *   {\n\t *     heading: \"<strong>C</strong>laude Monet\",\n\t *     id: undefined,\n\t *     title: \"Claude Monet\",\n\t *     displayTitle: \"<i>Claude Monet</i>\",\n\t *     url: \"/wiki/Claude_Monet\",\n\t *     thumbnail: {\n\t *       height: 62,\n\t *       source: \"http://127.0.0.1:8080/images/thumb/thumb.jpg\",\n\t *       width: 80,\n\t *       isLandscape: true\n\t *     }\n\t *   }\n\t * ]\n\t */\n\tget defaults() {\n\t\treturn {\n\t\t\tpages: []\n\t\t};\n\t}\n\n\t/**\n\t * Render page images for the existing page list. Assumes no page images have been loaded.\n\t */\n\trenderPageImages() {\n\t\tsetTimeout( () => {\n\t\t\tthis.$el.find( '.list-thumb' ).each( ( i, thumbEl ) => {\n\t\t\t\tconst style = this.$el.find( thumbEl ).data( 'style' );\n\t\t\t\tthis.$el.find( thumbEl ).attr( 'style', style );\n\t\t\t} );\n\t\t\t// Delay an unnecessary load of images on mobile (slower?) connections\n\t\t\t// In particular on search results which can be regenerated quickly.\n\t\t}, browser.isWideScreen() ? 0 : 1000 );\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpostRender() {\n\t\tthis.renderPageImages();\n\t}\n\n\tget template() {\n\t\treturn util.template( `\n<ul class=\"mw-mf-page-list thumbs actionable\">\n\t{{#pages}}\n\t\t{{>item}}\n\t{{/pages}}\n</ul>\n\t` );\n\t}\n\n\tget templatePartials() {\n\t\treturn {\n\t\t\t// The server uses a very different structure in\n\t\t\t// SpecialMobileEditWatchlist.getLineHtml(). Be aware of these differences\n\t\t\t// when updating server rendered items.\n\t\t\titem: util.template( `\n\t<li title=\"{{title}}\" data-id=\"{{id}}\" class=\"page-summary\">\n\t<a href=\"{{url}}\" class=\"title {{#isMissing}}new{{/isMissing}}\"\n\t\t{{#anchor}}name=\"{{anchor}}\"{{/anchor}}\n\t\tdata-title=\"{{title}}\">\n\t\t<div class=\"list-thumb\n\t\t{{#thumbnail.isLandscape}}list-thumb-y{{/thumbnail.isLandscape}}\n\t\t{{^thumbnail.isLandscape}}list-thumb-x{{/thumbnail.isLandscape}}\"\n\t\t{{#thumbnail}}data-style=\"background-image: url( {{thumbnail.source}} )\"{{/thumbnail}}>\n\t\t{{^thumbnail}}<span class=\"mf-icon-image\"></span>{{/thumbnail}}\n\t\t</div>\n\t\t<h3>{{{displayTitle}}}</h3>\n\t\t{{#wikidataDescription}}\n\t\t<div class=\"wikidata-description\">{{wikidataDescription}}</div>\n\t\t{{/wikidataDescription}}\n\t</a>\n\t</li>\n\t\t` )\n\t\t};\n\t}\n}\n\nmodule.exports = PageList;\n","const util = require( '../mobile.startup/util' );\n\n/**\n * Class to assist a view in implementing infinite scrolling on some DOM\n * element. This module itself is only responsible for emitting an Event when\n * the bottom of an Element is scrolled to.\n *\n * @class ScrollEndEventEmitter\n * @mixes OO.EventEmitter\n *\n * Use this class in a view to help it do infinite scrolling.\n *\n * 1. Initialize it in the constructor `initialize` and listen to the\n *   EVENT_SCROLL_END event it emits (and call your loading function then)\n * 2. On preRender (once we have the DOM element) set it into the infinite\n *   scrolling object and disable it until we've loaded.\n * 3. Once you have loaded the list and put it in the DOM, enable the\n *   infinite scrolling detection.\n *   - Every time the scroller detection triggers a load, it auto disables\n *     to not trigger multiple times. After you have loaded, manually\n *     re-enable it.\n *\n * Example:\n *     @example\n *     <code>\n *       var\n *         ScrollEndEventEmitter = require( './ScrollEndEventEmitter' ),\n *         eventBus = require( './eventBusSingleton' );\n *       class PhotoList extends View {\n *         //...\n *         initialize: function ( options ) {\n *           this.gateway = new PhotoListGateway( {\n *             username: options.username\n *           } );\n *           // 1. Set up infinite scroll helper and listen to events\n *           this.scrollEndEventEmitter = new ScrollEndEventEmitter( eventBus, 1000 );\n *           this.scrollEndEventEmitter.on( ScrollEndEventEmitter.EVENT_SCROLL_END,\n *             this._loadPhotos.bind( this ) );\n *           super.initialize( options );\n *         },\n *         preRender: function () {\n *           // 2. Disable until we've got the list rendered and set DOM el\n *           this.scrollEndEventEmitter.setElement( this.$el );\n *           this.scrollEndEventEmitter.disable();\n *         },\n *         _loadPhotos: function () {\n *           this.gateway.getPhotos().then( ( photos ) => {\n *             // load photos into the DOM ...\n *             // 3. and (re-)enable infinite scrolling\n *             this.scrollEndEventEmitter.enable();\n *           } );\n *         }\n *       }\n *     </code>\n *\n * @fires ScrollEndEventEmitter#ScrollEndEventEmitter-scrollEnd\n */\nclass ScrollEndEventEmitter {\n\t/**\n\t * @param {Object} eventBus object to listen for scroll:throttled events\n\t * @param {number} [threshold=100] distance in pixels used to calculate if scroll\n\t * position is near the end of the $el\n\t */\n\tconstructor( eventBus, threshold ) {\n\t\tthis.threshold = threshold || 100;\n\t\tthis.eventBus = eventBus;\n\t\tthis.enable();\n\t\tOO.EventEmitter.call( this );\n\t}\n\n\t/**\n\t * Listen to scroll on window and notify this._onScroll\n\t *\n\t * @private\n\t */\n\t_bindScroll() {\n\t\tif ( !this._scrollHandler ) {\n\t\t\tthis._scrollHandler = () => this._onScroll();\n\t\t\tthis.eventBus.on( 'scroll:throttled', this._scrollHandler );\n\t\t}\n\t}\n\n\t/**\n\t * Unbind scroll handler\n\t *\n\t * @private\n\t */\n\t_unbindScroll() {\n\t\tif ( this._scrollHandler ) {\n\t\t\tthis.eventBus.off( 'scroll:throttled', this._scrollHandler );\n\t\t\tthis._scrollHandler = null;\n\t\t}\n\t}\n\n\t/**\n\t * Scroll handler. Triggers load event when near the end of the container.\n\t *\n\t * @private\n\t */\n\t_onScroll() {\n\t\tif ( this.$el && this.enabled && this.scrollNearEnd() ) {\n\t\t\t// Disable when triggering an event. Won't trigger again until\n\t\t\t// re-enabled.\n\t\t\tthis.disable();\n\t\t\tthis.emit( ScrollEndEventEmitter.EVENT_SCROLL_END );\n\t\t}\n\t}\n\n\t/**\n\t * Is the scroll position near the end of the container element?\n\t *\n\t * @private\n\t * @return {boolean}\n\t */\n\tscrollNearEnd() {\n\t\tif ( !this.$el || !this.$el.offset() ) {\n\t\t\treturn false;\n\t\t}\n\t\tconst $window = util.getWindow(),\n\t\t\tscrollBottom = $window.scrollTop() + $window.height(),\n\t\t\tendPosition = this.$el.offset().top + this.$el.outerHeight();\n\t\treturn scrollBottom + this.threshold > endPosition;\n\t}\n\n\t/**\n\t * Enable the ScrollEndEventEmitter so that it triggers events.\n\t */\n\tenable() {\n\t\tthis.enabled = true;\n\t\tthis._bindScroll();\n\t}\n\n\t/**\n\t * Disable the ScrollEndEventEmitter so that it doesn't trigger events.\n\t */\n\tdisable() {\n\t\tthis.enabled = false;\n\t\tthis._unbindScroll();\n\t}\n\n\t/**\n\t * Set the element to compare to scroll position to\n\t *\n\t * @param {jQuery.Object} $el jQuery element where we want to listen for\n\t * scroll end.\n\t */\n\tsetElement( $el ) {\n\t\tthis.$el = $el;\n\t}\n}\nOO.mixinClass( ScrollEndEventEmitter, OO.EventEmitter );\n\n/**\n * Fired when scroll bottom has been reached.\n *\n * @event ScrollEndEventEmitter#ScrollEndEventEmitter-scrollEnd\n */\nScrollEndEventEmitter.EVENT_SCROLL_END = 'ScrollEndEventEmitter-scrollEnd';\n\nmodule.exports = ScrollEndEventEmitter;\n","const\n\tPageList = require( './PageList' ),\n\tWatchstarPageList = require( './WatchstarPageList' ),\n\tScrollEndEventEmitter = require( './ScrollEndEventEmitter' ),\n\tutil = require( '../mobile.startup/util' ),\n\tWatchListGateway = require( './WatchListGateway' );\n\n/**\n * An extension of the WatchstarPageList which preloads pages as all being\n * watched.\n *\n * @uses ScrollEndEventEmitter\n *\n * @fires watched\n * @fires watch\n * @private\n */\nclass WatchList extends WatchstarPageList {\n\t/**\n\t * @param {Object} params Configuration options\n\t * @param {OO.EventEmitter} params.eventBus Object used to listen for scroll:throttled events\n\t */\n\tconstructor( params ) {\n\t\tsuper( util.extend(\n\t\t\t{},\n\t\t\t{\n\t\t\t\tisBorderBox: false\n\t\t\t},\n\t\t\tparams\n\t\t) );\n\t}\n\n\tinitialize( options ) {\n\t\t// Set up infinite scroll helper and listen to events\n\t\tthis.scrollEndEventEmitter = new ScrollEndEventEmitter( options.eventBus );\n\t\tthis.scrollEndEventEmitter.on( ScrollEndEventEmitter.EVENT_SCROLL_END,\n\t\t\t() => this._loadPages() );\n\n\t\tlet lastTitle;\n\t\tif ( options.el ) {\n\t\t\tlastTitle = this.getLastTitle( options.el );\n\t\t}\n\t\tthis.gateway = new WatchListGateway( options.api, lastTitle );\n\t\tsuper.initialize( options );\n\t}\n\n\tpreRender() {\n\t\t// The DOM will be modified. Prevent any false scroll end events from\n\t\t// being emitted.\n\t\tthis.scrollEndEventEmitter.disable();\n\t\tthis.scrollEndEventEmitter.setElement( this.$el );\n\t}\n\n\t/**\n\t * Also sets a watch uploads funnel.\n\t *\n\t * @inheritdoc\n\t */\n\tpostRender() {\n\t\t// Skip a level from WatchstarPageList directly to PageList.\n\t\tPageList.prototype.postRender.apply( this );\n\n\t\tconst $items = this.queryUnitializedItems();\n\n\t\t// WatchList requests list of watched pages. The list contains only\n\t\t// watched pages so it's safe to transform the title map to a status map\n\t\t// with each entry marked watched (true).\n\t\tconst statuses = Object.keys( this.parsePagesFromItems( $items ) )\n\t\t\t.reduce( ( arr, title ) => {\n\t\t\t\tarr[ title ] = true;\n\t\t\t\treturn arr;\n\t\t\t}, {} );\n\t\tthis.renderItems( $items, statuses );\n\n\t\t// The list has been extended. Re-enable scroll end events.\n\t\tthis.scrollEndEventEmitter.enable();\n\t}\n\n\t/**\n\t * Loads pages from the api and triggers render.\n\t * Infinite scroll is re-enabled in postRender.\n\t *\n\t */\n\t_loadPages() {\n\t\tthis.gateway.loadWatchlist().then( ( pages ) => {\n\t\t\tpages.forEach( ( page ) => {\n\t\t\t\tthis.appendPage( page );\n\t\t\t} );\n\t\t\tthis.render();\n\t\t} );\n\t}\n\n\t/**\n\t * Appends a list item\n\t *\n\t * @param {Page} page\n\t */\n\tappendPage( page ) {\n\t\t// wikidata descriptions should not show in this view.\n\t\tconst templateOptions = util.extend( {}, page, {\n\t\t\twikidataDescription: undefined\n\t\t} );\n\t\tthis.$el.append( this.templatePartials.item.render( templateOptions ) );\n\t}\n\n\t/**\n\t * Get the last title from the rendered HTML.\n\t * Used for initializing the API\n\t *\n\t * @param {jQuery.Object} $el Dom element of the list\n\t * @return {string}\n\t */\n\tgetLastTitle( $el ) {\n\t\treturn $el.find( 'li' ).last().attr( 'title' );\n\t}\n}\n\nmodule.exports = WatchList;\n","const\n\tpageJSONParser = require( './pageJSONParser' ),\n\tutil = require( '../mobile.startup/util' ),\n\textendSearchParams = require( './extendSearchParams' );\n\n/**\n * API for interacting with watchlist.\n */\nclass WatchListGateway {\n\t/**\n\t * @param {mw.Api} api\n\t * @param {string} lastTitle of page listed in Watchlist to be used as a continuation parameter\n\t * @private\n\t */\n\tconstructor( api, lastTitle ) {\n\t\tthis.api = api;\n\t\t// Try to keep it in sync with SpecialMobileEditWatchlist::LIMIT (php)\n\t\tthis.limit = 50;\n\n\t\tif ( lastTitle ) {\n\t\t\tthis.continueParams = {\n\t\t\t\tcontinue: 'gwrcontinue||',\n\t\t\t\tgwrcontinue: '0|' + lastTitle.replace( / /g, '_' )\n\t\t\t};\n\t\t\tthis.shouldSkipFirstTitle = true;\n\t\t} else {\n\t\t\tthis.continueParams = {\n\t\t\t\tcontinue: ''\n\t\t\t};\n\t\t\tthis.shouldSkipFirstTitle = false;\n\t\t}\n\n\t\tthis.canContinue = true;\n\t}\n\n\t/**\n\t * Load the list of items on the watchlist\n\t *\n\t * @return {jQuery.Deferred}\n\t */\n\tloadWatchlist() {\n\t\tconst params = extendSearchParams( 'watchlist', {\n\t\t\tprop: [ 'info', 'revisions' ],\n\t\t\trvprop: 'timestamp|user',\n\t\t\tgenerator: 'watchlistraw',\n\t\t\tgwrnamespace: '0',\n\t\t\tgwrlimit: this.limit\n\t\t}, this.continueParams );\n\n\t\tif ( this.canContinue === false ) {\n\t\t\treturn util.Deferred().resolve( [] );\n\t\t}\n\t\treturn this.api.get( params ).then( ( data ) => {\n\t\t\tif ( data.continue !== undefined ) {\n\t\t\t\tthis.continueParams = data.continue;\n\t\t\t} else {\n\t\t\t\tthis.canContinue = false;\n\t\t\t}\n\n\t\t\treturn this.parseData( data );\n\t\t} );\n\t}\n\n\t/**\n\t * Parse api response data into pagelist item format\n\t *\n\t * @param {Object[]} data\n\t * @return {Page[]}\n\t */\n\tparseData( data ) {\n\t\tlet pages;\n\n\t\tif ( !data.query || !data.query.pages ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tpages = data.query.pages;\n\n\t\t// Sort results alphabetically (the api map doesn't have any order). The\n\t\t// watchlist is ordered alphabetically right now.\n\t\tpages.sort( ( p1, p2 ) => p1.title === p2.title ? 0 : ( p1.title < p2.title ? -1 : 1 ) );\n\n\t\t// If we requested from the last item of the previous page, we shall\n\t\t// remove the first result (to avoid it being repeated)\n\t\tif ( this.shouldSkipFirstTitle ) {\n\t\t\tpages = pages.slice( 1 );\n\t\t\tthis.shouldSkipFirstTitle = false;\n\t\t}\n\n\t\t// Transform the items to a sensible format\n\t\treturn pages.map( pageJSONParser.parse );\n\t}\n}\n\nmodule.exports = WatchListGateway;\n","const util = require( '../mobile.startup/util' ),\n\tactionParams = require( '../mobile.startup/actionParams' );\n\n/**\n * @ignore\n * @typedef {string|number} PageID Page ID. 0 / \"0\" is a special no-ID value.\n * {@link https://www.mediawiki.org/wiki/Manual:Page_table#page_id Page ID}\n *\n * @ignore\n * @typedef {string} PageTitle Canonical page title.\n * {@link https://www.mediawiki.org/wiki/Manual:Title.php#Canonical_forms Canonical forms}\n *\n * @ignore\n * @typedef {boolean} WatchStatus Page watch status; true if watched, false if\n *                                unwatched.\n * {@link https://www.mediawiki.org/wiki/API:Info API:Info} (see inprop.watched)\n * {@link https://www.mediawiki.org/wiki/API:Watch API:Watch} (see unwatch)\n *\n * @ignore\n * @typedef {Object.<PageTitle, WatchStatus>} WatchStatusMap\n */\n\n/**\n * API for retrieving and modifying page watch statuses. This module interacts\n * with two endpoints, API:Info for GETs and API:Watch and for POSTs.\n */\nclass WatchstarGateway {\n\t/**\n\t * @param {mw.Api} api\n\t */\n\tconstructor( api ) {\n\t\tthis.api = api;\n\t}\n\n\t/**\n\t * Issues zero to two asynchronous HTTP requests for the watch status of\n\t * each page ID and title passed.\n\t *\n\t * Every watch entry has a title but not necessarily a page ID. Entries\n\t * without IDs are missing pages, i.e., pages that do not exist. These\n\t * entries are used to observe when a page with a given title is created.\n\t * Although it is convenient to use titles because they're always present,\n\t * IDs are preferred since they're far less likely to exceed the URL length\n\t * limit.\n\t *\n\t * No request is issued when no IDs and no titles are passed. Given that the\n\t * server state does not change between the two requests, overlapping title\n\t * and ID members will behave as expected but there is no reason to issue\n\t * such a request.\n\t *\n\t * @param {PageID[]} ids\n\t * @param {PageTitle[]} titles\n\t * @return {jQuery.Deferred<WatchStatusMap>}\n\t */\n\tgetStatuses( ids, titles ) {\n\t\t// Issue two requests and coalesce the results.\n\t\treturn util.Promise.all( [\n\t\t\tthis.getStatusesByID( ids ),\n\t\t\tthis.getStatusesByTitle( titles )\n\t\t] ).then( function () {\n\t\t\treturn util.extend.apply( util, arguments );\n\t\t} );\n\t}\n\n\t/**\n\t * @param {PageID[]} ids\n\t * @return {jQuery.Deferred<WatchStatusMap>}\n\t */\n\tgetStatusesByID( ids ) {\n\t\tif ( !ids.length ) {\n\t\t\treturn util.Deferred().resolve( {} );\n\t\t}\n\n\t\treturn this.api.get( {\n\t\t\tformatversion: 2,\n\t\t\taction: 'query',\n\t\t\tprop: 'info',\n\t\t\tinprop: 'watched',\n\t\t\tpageids: ids\n\t\t} ).then( ( rsp ) => this._unmarshalGetResponse( rsp ) );\n\t}\n\n\t/**\n\t * @param {PageTitle[]} titles\n\t * @return {jQuery.Deferred<WatchStatusMap>}\n\t */\n\tgetStatusesByTitle( titles ) {\n\t\tif ( !titles.length ) {\n\t\t\treturn util.Deferred().resolve( {} );\n\t\t}\n\n\t\treturn this.api.get( actionParams( {\n\t\t\tprop: 'info',\n\t\t\tinprop: 'watched',\n\t\t\ttitles\n\t\t} ) ).then( ( rsp ) => this._unmarshalGetResponse( rsp ) );\n\t}\n\n\t/**\n\t * @param {PageTitle[]} titles\n\t * @param {WatchStatus} watched\n\t * @return {jQuery.Deferred}\n\t */\n\tpostStatusesByTitle( titles, watched ) {\n\t\tconst params = {\n\t\t\taction: 'watch',\n\t\t\ttitles\n\t\t};\n\t\tif ( !watched ) {\n\t\t\tparams.unwatch = !watched;\n\t\t}\n\t\treturn this.api.postWithToken( 'watch', params );\n\t}\n\n\t/**\n\t * @param {Object} rsp The API:Info response.\n\t * @return {jQuery.Deferred<WatchStatusMap>}\n\t * @see getStatusesByID\n\t * @see getStatusesByTitle\n\t * @ignore\n\t */\n\t_unmarshalGetResponse( rsp ) {\n\t\tconst pages = rsp && rsp.query && rsp.query.pages || [];\n\t\treturn pages.reduce( ( statuses, page ) => {\n\t\t\tstatuses[page.title] = page.watched;\n\t\t\treturn statuses;\n\t\t}, {} );\n\t}\n}\n\nmodule.exports = WatchstarGateway;\n","const PageList = require( './PageList' ),\n\twatchstar = require( './watchstar' ),\n\tuser = mw.user,\n\tutil = require( '../mobile.startup/util' ),\n\tPage = require( '../mobile.startup/Page' ),\n\tWatchstarGateway = require( './WatchstarGateway' );\n\n/**\n * @typedef {Object.<PageTitle, PageID>} PageTitleToPageIDMap\n * @ignore\n */\n\n/**\n * List of items page view\n *\n * @uses Page\n * @uses WatchstarGateway\n * @uses Watchstar\n * @ignore\n *\n * @fires WatchstarPageList#unwatch\n * @fires WatchstarPageList#watch\n */\nclass WatchstarPageList extends PageList {\n\n\t/**\n\t * @param {Object} options Configuration options\n\t */\n\tconstructor( options ) {\n\t\tsuper( options );\n\t}\n\n\tinitialize( options ) {\n\t\tthis.wsGateway = new WatchstarGateway( options.api );\n\t\tsuper.initialize( options );\n\t}\n\n\t/**\n\t * @instance\n\t * @mixes PageList#defaults\n\t * @property {Object} defaults Default options hash.\n\t * @property {mw.Api} defaults.api\n\t */\n\tpostRender() {\n\t\tconst\n\t\t\tids = [],\n\t\t\ttitles = [];\n\n\t\tsuper.postRender();\n\n\t\tconst $items = this.queryUnitializedItems();\n\t\tconst pages = this.parsePagesFromItems( $items );\n\n\t\tObject.keys( pages ).forEach( ( title ) => {\n\t\t\tconst id = pages[title];\n\t\t\t// Favor IDs since they're short and unlikely to exceed URL length\n\t\t\t// limits when batched.\n\t\t\tif ( id && id !== '0' ) {\n\t\t\t\t// ID is present and valid.\n\t\t\t\tids.push( id );\n\t\t\t} else {\n\t\t\t\t// Only titles are available for missing pages.\n\t\t\t\ttitles.push( title );\n\t\t\t}\n\t\t} );\n\n\t\treturn this.getPages( ids, titles )\n\t\t\t.then( ( statuses ) => this.renderItems( $items, statuses ) );\n\t}\n\n\t/**\n\t * @param {jQuery.Element} $items\n\t * @param {WatchStatusMap} statuses\n\t * @ignore\n\t */\n\tqueryUnitializedItems() {\n\t\treturn this.$el.find( 'li:not(.with-watchstar)' );\n\t}\n\n\t/**\n\t * Retrieve pages\n\t *\n\t * @instance\n\t * @param {PageID[]} ids\n\t * @param {PageTitle[]} titles\n\t * @return {jQuery.Deferred<WatchStatusMap>}\n\t * @ignore\n\t */\n\tgetPages( ids, titles ) {\n\t\t// Rendering Watchstars for anonymous users is not useful. Short-circuit\n\t\t// the request.\n\t\tif ( user.isAnon() ) {\n\t\t\treturn util.Deferred().resolve( {} );\n\t\t}\n\n\t\treturn this.wsGateway.getStatuses( ids, titles );\n\t}\n\n\t/**\n\t * @param {jQuery.Element} $items\n\t * @return {PageTitleToPageIDMap}\n\t * @ignore\n\t */\n\tparsePagesFromItems( $items ) {\n\t\tconst\n\t\t\tpages = {};\n\t\t$items.each( ( _, item ) => {\n\t\t\tconst $item = this.$el.find( item );\n\t\t\tpages[$item.attr( 'title' )] = $item.data( 'id' );\n\t\t} );\n\t\treturn pages;\n\t}\n\n\t/**\n\t * @param {jQuery.Element} $items\n\t * @param {WatchStatusMap} statuses\n\t * @ignore\n\t */\n\trenderItems( $items, statuses ) {\n\t\t// Rendering Watchstars for anonymous users is not useful. Nothing to do.\n\t\tif ( user.isAnon() ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create watch stars for each entry in list\n\t\t$items.each( ( _, item ) => {\n\t\t\tconst\n\t\t\t\t$item = this.$el.find( item ),\n\t\t\t\tpage = new Page( {\n\t\t\t\t\t// FIXME: Set sections so we don't hit the api (hacky)\n\t\t\t\t\tsections: [],\n\t\t\t\t\ttitle: $item.attr( 'title' ),\n\t\t\t\t\tid: $item.data( 'id' )\n\t\t\t\t} ),\n\t\t\t\twatched = statuses[page.getTitle()];\n\n\t\t\tthis._appendWatchstar( $item, page, watched );\n\t\t\t$item.addClass( 'with-watchstar' );\n\t\t} );\n\t}\n\n\t/**\n\t * @param {jQuery.Object} $item\n\t * @param {Page} page\n\t * @param {WatchStatus} watched\n\t * @private\n\t */\n\t_appendWatchstar( $item, page, watched ) {\n\t\twatchstar( {\n\t\t\t// WatchstarPageList.getPages() already retrieved the status of\n\t\t\t// each page. Explicitly set the watch state so another request\n\t\t\t// will not be issued by the Watchstar.\n\t\t\tisWatched: watched,\n\t\t\tpage\n\t\t} ).appendTo( $item );\n\t}\n}\n\nmodule.exports = WatchstarPageList;\n","const util = require( '../mobile.startup/util.js' ),\n\tactionParams = require( '../mobile.startup/actionParams.js' );\n\n/**\n * Extends the API query parameters to include those parameters required to also fetch Wikibase\n * descriptions and appropriately sized thumbnail images as well as those required to make a query.\n *\n * This function wraps `util.extend` with some Wikibase-specific configuration\n * variable management\n * but, like `util.extend`, is variadic and so can be used as a replacement for it in search\n * gateways, e.g.\n *\n * ```\n * var params = extendSearchParams(\n *   'search',\n *   baseParams,\n *   specializedParams,\n *   moreSpecializedParams\n * );\n * ```\n *\n * @param {string} feature The name of the feature\n * @throws {Error} If `feature` isn't one that shows Wikidata descriptions. See the\n *  `wgMFDisplayWikibaseDescriptions` configuration variable for detail\n * @return {Object}\n */\nmodule.exports = function extendSearchParams( feature ) {\n\t// These must be defined, as these are all the features that this can be used on.\n\t// If not defined, all these features will see their API calls broken\n\tconst displayWikibaseDescriptions = mw.config.get( 'wgMFDisplayWikibaseDescriptions' ) || {\n\t\twatchlist: true\n\t};\n\n\tif ( !Object.prototype.hasOwnProperty.call( displayWikibaseDescriptions, feature ) ) {\n\t\tthrow new Error( '\"' + feature + '\" isn\\'t a feature that shows Wikibase descriptions.' );\n\t}\n\n\t// Construct the arguments for a call to `util.extend`\n\t// such that if it were hand-written, then it\n\t// would look like the following:\n\t//\n\t// ```\n\t// var result = util.extend( {\n\t//   prop: []\n\t// }, params, /* ..., */ mw.config.get( 'wgMFSearchAPIParams' ) );\n\t// ```\n\tconst args = Array.prototype.slice.call( arguments, 1 );\n\targs.unshift( {\n\t\tprop: []\n\t} );\n\targs.push( mw.config.get( 'wgMFSearchAPIParams' ) );\n\n\tconst result = util.extend.apply( {}, args );\n\tresult.prop = result.prop.concat( mw.config.get( 'wgMFQueryPropModules' ) );\n\n\tif ( displayWikibaseDescriptions[feature] ) {\n\t\tif ( result.prop.indexOf( 'description' ) === -1 ) {\n\t\t\tresult.prop.push( 'description' );\n\t\t}\n\t}\n\n\treturn actionParams( result );\n};\n","/* global $ */\nconst WatchList = require( './WatchList' ),\n\teventBus = require( '../mobile.startup/eventBusSingleton' );\n\n/**\n * Initialises JavaScript on Special:Watchlist\n *\n * @private\n */\nfunction init() {\n\tconst $watchlist = $( 'ul.mw-mf-watchlist-page-list' );\n\n\t// FIXME: find more elegant way to not show watchlist stars on recent changes\n\tif ( $( '.mw-mf-watchlist-selector' ).length === 0 ) {\n\t\t// eslint-disable-next-line no-new\n\t\tnew WatchList( {\n\t\t\tapi: new mw.Api(),\n\t\t\tel: $watchlist,\n\t\t\tfunnel: 'watchlist',\n\t\t\tskipTemplateRender: true,\n\t\t\teventBus\n\t\t} );\n\t}\n\t// not needed now we have JS view which has infinite scrolling\n\t$watchlist.find( '.mw-mf-watchlist-more' ).remove();\n}\n\n$( () => {\n\tinit();\n} );\n","const Page = require( '../mobile.startup/Page' );\nconst util = require( '../mobile.startup/util' );\n\n/**\n * Create a Page object from an API response.\n *\n * @memberof Page\n * @param {Object} resp as representing a page in the API\n * @return {Page}\n */\nfunction parse( resp ) {\n\tlet displayTitle;\n\tconst thumb = resp.thumbnail,\n\t\tpageprops = resp.pageprops || {\n\t\t\tdisplaytitle: mw.html.escape( resp.title )\n\t\t},\n\t\tterms = resp.terms || resp.entityterms;\n\n\tif ( pageprops || terms ) {\n\t\t// The label is either the display title or the label pageprop\n\t\t// (the latter used by Wikidata)\n\t\t// Long term we want to consolidate these.\n\t\t// Note that pageprops.displaytitle is HTML, while\n\t\t// terms.label[0] is plain text.\n\t\tdisplayTitle = terms && terms.label ?\n\t\t\tmw.html.escape( terms.label[0] ) : pageprops.displaytitle;\n\t}\n\t// Add Wikidata descriptions if available (T101719)\n\tresp.wikidataDescription = resp.description || undefined;\n\n\tif ( thumb ) {\n\t\tresp.thumbnail.isLandscape = thumb.width > thumb.height;\n\t}\n\n\treturn new Page(\n\t\tutil.extend( resp, {\n\t\t\tid: resp.pageid,\n\t\t\tisMissing: !!resp.missing,\n\t\t\turl: mw.util.getUrl( resp.title ),\n\t\t\tdisplayTitle // this is HTML!\n\t\t} )\n\t);\n}\n\nmodule.exports = { parse };\n","const icons = require( '../mobile.startup/icons' );\n\n/**\n * A clickable watchstar for logged in users.\n * Should not be used for anonymous users.\n *\n * @param {Object} options Configuration options\n * @param {Page} options.page\n * @param {boolean} options.isWatched is the article watched?\n * @return {IconButton}\n */\nmodule.exports = function ( options ) {\n\tconst isWatched = options.isWatched,\n\t\twatchstar = __non_webpack_require__( 'mediawiki.page.watch.ajax' ).watchstar,\n\t\taction = isWatched ? 'unwatch' : 'watch',\n\t\ticonProps = {\n\t\t\thref: mw.Title.newFromText( options.page.title ).getUrl( { action } )\n\t\t},\n\t\twatchButton = icons.watch( iconProps ),\n\t\twatchedButton = icons.watched( iconProps ),\n\t\tWATCH_BUTTON_CLASS = watchButton.getClassName(),\n\t\tWATCHED_BUTTON_CLASS = watchedButton.getClassName(),\n\t\tWATCH_CLASS = watchButton.getIcon().getClassName(),\n\t\tWATCHED_CLASS = watchedButton.getIcon().getClassName(),\n\t\tactiveIcon = isWatched ? watchedButton : watchButton,\n\t\tcallback = ( $link, watched ) => {\n\t\t\t$link.attr( 'class', watched ?\n\t\t\t\tWATCHED_BUTTON_CLASS : WATCH_BUTTON_CLASS );\n\t\t\tconst $icon = $link.find( '.mf-icon' );\n\t\t\t$icon.attr( 'class', watched ?\n\t\t\t\tWATCHED_CLASS : WATCH_CLASS );\n\t\t};\n\n\twatchstar( activeIcon.$el, options.page.title, callback );\n\treturn activeIcon;\n};\n"],"names":["util","View","browser","module","exports","constructor","params","super","defaults","pages","renderPageImages","setTimeout","this","$el","find","each","i","thumbEl","style","data","attr","isWideScreen","postRender","template","templatePartials","item","ScrollEndEventEmitter","eventBus","threshold","enable","OO","EventEmitter","call","_bindScroll","_scrollHandler","_onScroll","on","_unbindScroll","off","enabled","scrollNearEnd","disable","emit","EVENT_SCROLL_END","offset","$window","getWindow","scrollBottom","scrollTop","height","endPosition","top","outerHeight","setElement","mixinClass","PageList","WatchstarPageList","WatchListGateway","extend","isBorderBox","initialize","options","lastTitle","scrollEndEventEmitter","_loadPages","el","getLastTitle","gateway","api","preRender","prototype","apply","$items","queryUnitializedItems","statuses","Object","keys","parsePagesFromItems","reduce","arr","title","renderItems","loadWatchlist","then","forEach","page","appendPage","render","templateOptions","wikidataDescription","undefined","append","last","pageJSONParser","extendSearchParams","limit","continueParams","continue","gwrcontinue","replace","shouldSkipFirstTitle","canContinue","prop","rvprop","generator","gwrnamespace","gwrlimit","Deferred","resolve","get","parseData","query","sort","p1","p2","slice","map","parse","actionParams","getStatuses","ids","titles","Promise","all","getStatusesByID","getStatusesByTitle","arguments","length","formatversion","action","inprop","pageids","rsp","_unmarshalGetResponse","postStatusesByTitle","watched","unwatch","postWithToken","watchstar","user","mw","Page","WatchstarGateway","wsGateway","id","push","getPages","isAnon","_","$item","sections","getTitle","_appendWatchstar","addClass","isWatched","appendTo","feature","displayWikibaseDescriptions","config","watchlist","hasOwnProperty","Error","args","Array","unshift","result","concat","indexOf","WatchList","$","$watchlist","Api","funnel","skipTemplateRender","remove","init","resp","displayTitle","thumb","thumbnail","pageprops","displaytitle","html","escape","terms","entityterms","label","description","isLandscape","width","pageid","isMissing","missing","url","getUrl","icons","iconProps","href","Title","newFromText","watchButton","watch","watchedButton","WATCH_BUTTON_CLASS","getClassName","WATCHED_BUTTON_CLASS","WATCH_CLASS","getIcon","WATCHED_CLASS","activeIcon","$link"],"sourceRoot":""}