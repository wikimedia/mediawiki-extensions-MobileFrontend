{
  "comments": [
    {
      "key": {
        "uuid": "0e1cb3f9_fc6e6592",
        "filename": "includes/MobileFormatter.php",
        "patchSetId": 2
      },
      "lineNbr": 648,
      "author": {
        "id": 221
      },
      "writtenOn": "2017-05-09T13:51:25Z",
      "side": 1,
      "message": "If some strange interaction of hook functions or the like results in a document with multiple `\u003cdiv class\u003d\"mw-parser-output\"\u003e` and no other top-level elements, this will process only the last one.\n\nThat\u0027s an unlikely situation though.",
      "revId": "22afb7ab0f6499592a53f0f1006f8614b9b2ffbe",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e1cb3f9_500bb0d9",
        "filename": "includes/MobileFormatter.php",
        "patchSetId": 2
      },
      "lineNbr": 648,
      "author": {
        "id": 17
      },
      "writtenOn": "2017-05-10T00:04:23Z",
      "side": 1,
      "message": "I did some code review to figure out how likely. The HTML we are parsing here actually comes from OutputPage::getHTML(), during the OutputPageBeforeHTML hook. As such it could have arbitrary quantities of hook-generated crap in it. Various other hooks could have modified the output buffer, appending, prepending, or even wrapping or replacing. So the question is how hard we want to try to figure out what is going on. I don\u0027t think it makes sense to use the \u003cbody\u003e as the top level just because a hook appends an element.\n\nI am now leaning towards XPath //body/div[@class\u003d\"mw-parser-output\"][1], i.e. the first child of the body which is a \u003cdiv\u003e with class\u003d\"mw-parser-output\".",
      "parentUuid": "0e1cb3f9_fc6e6592",
      "revId": "22afb7ab0f6499592a53f0f1006f8614b9b2ffbe",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e1cb3f9_d14edf3b",
        "filename": "includes/MobileFormatter.php",
        "patchSetId": 2
      },
      "lineNbr": 648,
      "author": {
        "id": 221
      },
      "writtenOn": "2017-05-10T15:29:09Z",
      "side": 1,
      "message": "\u003e The HTML we are parsing here actually comes from OutputPage::getHTML(), during the OutputPageBeforeHTML hook\n\nIt looks to me that it comes from the ParserOutput object that was passed to OutputPage::addParserOutputText(), unless that ParserOutput contains the empty string.\n\nThe hook gets passed $parserOutput-\u003egetText(), which MobileFrontendHooks::onOutputPageBeforeHTML() passes on to ExtMobileFrontend::DOMParse(), which only uses $out-\u003egetHTML() if $text is falsey.\n\nThat\u0027s not to say other hooks couldn\u0027t have modified the ParserOutput, or hooked OutputPageBeforeHTML and modified $text before MobileFrontend sees it.",
      "parentUuid": "0e1cb3f9_500bb0d9",
      "revId": "22afb7ab0f6499592a53f0f1006f8614b9b2ffbe",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e1cb3f9_1fc46b43",
        "filename": "includes/MobileFormatter.php",
        "patchSetId": 2
      },
      "lineNbr": 651,
      "author": {
        "id": 3945
      },
      "writtenOn": "2017-05-09T17:27:09Z",
      "side": 1,
      "message": "this is pretty strange contruction, we assign value to $node variable twice, why? while() loop looks more appropriate here.",
      "revId": "22afb7ab0f6499592a53f0f1006f8614b9b2ffbe",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e1cb3f9_1f41cbac",
        "filename": "includes/MobileFormatter.php",
        "patchSetId": 2
      },
      "lineNbr": 651,
      "author": {
        "id": 221
      },
      "writtenOn": "2017-05-09T17:39:39Z",
      "side": 1,
      "message": "That\u0027s a very strange question. A for loop of this form is roughly equivalent to \n\n  $node \u003d $containerChild;\n  while ( $node ) {\n      // Body is executed here\n      // This simplified equivalence assumes no\n      // \"continue\" statements in the body.\n\n      $node \u003d $node-\u003enextSibling;\n  }\n\nIt\u0027s used because it\u0027s a more convenient syntax in cases like this: it takes fewer lines, it separates iteration management from the body of the loop, and it doesn\u0027t need special work to support \u0027continue\u0027 should that be needed.",
      "parentUuid": "0e1cb3f9_1fc46b43",
      "revId": "22afb7ab0f6499592a53f0f1006f8614b9b2ffbe",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e1cb3f9_c5ff00a6",
        "filename": "includes/MobileFormatter.php",
        "patchSetId": 2
      },
      "lineNbr": 651,
      "author": {
        "id": 3945
      },
      "writtenOn": "2017-05-09T21:09:16Z",
      "side": 1,
      "message": "My question was more about the general approach. To iterate over items usually do{}while()|while(){}|foreach() is used where for() loop is used mostly to repeat a section of code known number of times. I\u0027m not saying it\u0027s bad, but tbh it took me a while to understand whats going here as this is the first time when I see for() statement in such scenario.",
      "parentUuid": "0e1cb3f9_1f41cbac",
      "revId": "22afb7ab0f6499592a53f0f1006f8614b9b2ffbe",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e1cb3f9_109bf8c2",
        "filename": "includes/MobileFormatter.php",
        "patchSetId": 2
      },
      "lineNbr": 651,
      "author": {
        "id": 17
      },
      "writtenOn": "2017-05-10T00:04:23Z",
      "side": 1,
      "message": "It\u0027s a normal way to iterate through linked lists, in C and C-like languages.",
      "parentUuid": "0e1cb3f9_c5ff00a6",
      "revId": "22afb7ab0f6499592a53f0f1006f8614b9b2ffbe",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e1cb3f9_bfc0df30",
        "filename": "includes/MobileFormatter.php",
        "patchSetId": 2
      },
      "lineNbr": 652,
      "author": {
        "id": 3945
      },
      "writtenOn": "2017-05-09T17:27:09Z",
      "side": 1,
      "message": "in many places in MobileFormatter we use an XPath::query() instead of manual traversing. It would be nice to stick to one method.",
      "revId": "22afb7ab0f6499592a53f0f1006f8614b9b2ffbe",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e1cb3f9_d0ffc0a5",
        "filename": "includes/MobileFormatter.php",
        "patchSetId": 2
      },
      "lineNbr": 652,
      "author": {
        "id": 17
      },
      "writtenOn": "2017-05-10T00:04:23Z",
      "side": 1,
      "message": "I was implementing an algorithm which didn\u0027t have an XPath equivalent.",
      "parentUuid": "0e1cb3f9_bfc0df30",
      "revId": "22afb7ab0f6499592a53f0f1006f8614b9b2ffbe",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    }
  ]
}